## Airport Challenge
### Makers, Week 1

#

We were asked to respond to the six user stories in CHALLENGE.md (renamed from README to avoid a conflict with this file!)

#

### How I met the specification :-)

- Allowed planes to take off and land at an airport

- Prevented landing at full airports

- Prevented takeoff and landing in bad weather

- Allowed overriding default airport capacity

- Dealt with edge cases:
  
  - Prevented takeoff of a plane that is not in airport

  - Prevented landing of a plane that is not in the air
  
  - Only allowed planes to land

- Completed the challenge using a TDD workflow

  - Performed manual feature tests in IRB

  - Wrote failing unit tests in rspec
  
  - Wrote code to pass these tests
  
  - Refactored where necessary
  
  - Retested after refactoring
  
  - Ran rubocop
  
  - Committed to git repo

- Achieved 100% test coverage

- Kept each class, module and test suite in a seperate file

- Kept methods short and with a single-responsibility

- Used rubocop to ensure an acceptable style

### How I _didn't_ meet the specification :-/

- Did not use a random number generator to set the weather

- Did not override the weather in the tests using doubles and stubs

- Did not write an rspec feature test (bonus challenge)

#

## Implementation

#

My submission includes two classes, `Plane` and `Airport`, and a module, `Weather`

### `Plane`

- is initialized with a single argument with a default value of **false**, which is assigned to the variable `in_flight`

- has three public methods:

  - `takeoff` and `land`, which set `in_flight` to **true** or **false** respectively and â”€

  - `in_flight?` which returns its value

### `Airport`

- is initialized with three arguments:

  - `capacity` indicating the maximum number of planes permitted to land at the airport, with a default of 1

  - `weather` indicating the current weather at the airport, whose default is generated by `Weather.random` as being either `:clear` or `:stormy`

  - `planes` indicating all the planes which are currently at the airport, with an empty array `[]` as its default value

- has four private methods:

  - `clear_for_landing` takes a `Plane` object as an argument and checks that:
  
    - the plane is a type of `Plane`
    
    - the plane is `in_flight`
    
    - landing is `safe?`
    
    - the airport is **not** `full?`
    
    otherwise raises an error

  - `clear_for_takeoff` takes a `Plane` object as an argument and checks that:

    - that the plane is **not** already `in_flight?`
    
    - the plane is present at the airport in the list of `planes`
    
    - takeoff is `safe?`
    
    otherwise raises an error

  - `full?` which is **true** when the size of `planes` has reached the airport `capacity`

  - `safe?` which is **true** if the `weather` at the airport is `:clear`, **false** in any other case

- has two explicitly defined public methods:

  - `recieve` takes a `Plane` object and:

    - calls `clear_for_landing`

    - if no errors are raised, allows the plane to `land` and adds it to the list of `planes` 
  
  - `release` takes a `Plane` object and:

    - calls `clear_for_takeoff`

    - if no errors are raised, allows the plane to `takeoff` and removes it from the list of `planes`

- has two methods, `capacity` and `capacity=` which are defined via `attr_accessor` to allow viewing and changing the capacity after an airport is initialized

### `Weather`

- has two objects:

  - `@@states`, an array containing the symbols `:clear` and `:stormy` in amounts reflecting the frequency of their occurance

  - `self.random` which calls `@@states.sample` to produce a weighted sample of either `:clear` or `:stormy` and returns the result

